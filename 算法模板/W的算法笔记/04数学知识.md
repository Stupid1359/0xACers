# 数学知识



## 数论

### 质数

#### 试除法判定质数

$O(\sqrt n)$

```cpp
bool is_prime(int x)
{
    if (x < 2) return false;
    for (int i = 2; i <= x / i; i ++ )//sqrt(x)较慢，i*i存在溢出风险
        if (x % i == 0)
            return false;
    return true;
}
```



#### 试除法分解质因数

$O(\log n) \sim O(\sqrt n)$

$n$ 中最多只包含一个大于$\sqrt n$ 的质因子

```cpp
void divide(int x)
{
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            int s = 0;
            while (x % i == 0) x /= i, s ++ ;
            cout << i << ' ' << s << endl;
        }
    if (x > 1) cout << x << ' ' << 1 << endl;
    cout << endl;
}
```



#### 埃氏筛求质数

$O(n \log (\log n))$

```cpp
int primes[N], cnt;//primes[]存储所有素数
bool st[N];//st[x]存储x是否被筛掉
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (st[i]) continue;
        primes[cnt ++ ] = i;
        for (int j = i + i; j <= n; j += i)
            st[j] = true;
    }
}
```



#### 线性筛求质数

$O(n)$

每个数只被它最小的质因数筛去

```cpp
int primes[N], cnt;     // primes[]存储所有素数
bool st[N];         // st[x]存储x是否被筛掉
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}
```



### 约数

#### 试除法求约数

```cpp
vector<int> get_divisors(int x)
{
    vector<int> res;
    for (int i = 1; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res.push_back(i);
            if (i != x / i) res.push_back(x / i);
        }
    sort(res.begin(), res.end());
    return res;
}
```



#### 约数个数与约数之和

如果 $N = p_1^{c_1} \times p_2^{c_2} \dots p_k^{c_k}$
**约数个数：**$(c_1 + 1) \times (c_2 + 1) ... (c_k + 1)$
**约数之和：**$(p_1^0 + p_1^1 + ... + p_1^{c_1}) \times ... \times (p_k^0 + p_k^1 + ... + p_k^{c_k})$



####  欧几里得算法

$(a,b)=(b,a\bmod b)$

```cpp
int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}
```



### 欧拉函数

**欧拉函数 $\varphi (n) : 1\sim n$ 中和 $n$ 互质的个数**

**欧拉定理：**若 $gcd(a,m)=1$ ,则 $a^{\varphi (m)}\equiv 1\pmod{m}$

**费马小定理：**若 $p$ 为素数，$gcd(a,p)=1$，则 $a^{p-1}\equiv 1\pmod{p}$

#### 求欧拉函数

$O(\sqrt{n})$

若 $n=p_1^{\alpha_1}\cdot p_2^{\alpha_2} \cdots p_k^{\alpha_k}$

1.   从 $1\sim n$ 中去掉 $p_1,p_2,\ldots p_k$ 的所有倍数
2.   加上所有 $p_i \cdot p_j$ 的倍数
3.   减去所有 $p_i \cdot p_j \cdot p_k$ 的倍数
4.   $\cdots\cdots$（容斥原理）

$$\begin{aligned}
N & -\frac{N}{p_1}-\frac{N}{p_2} \cdots -\frac{N}{p_k} \\
& +\frac{N}{p_1 \cdot p_2}+\frac{N}{p_1 \cdot p_3}+ \cdots \\
& -\frac{N}{p_1 \cdot p_2 \cdot p_3}-\frac{N}{p_1 \cdot p_2 \cdot p_4}-\cdots \\
& +\frac{N}{p_1 \cdot p_2 \cdot p_3 \cdot p_4} \cdots\cdots \\
= & N(1-\frac{1}{p_1})(1-\frac{1}{p_2}) \cdots (1-\frac{1}{p_k}) \\
\end{aligned}$$

```cpp
int phi(int x)
{
    int res = x;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res = res / i * (i - 1);
            while (x % i == 0) x /= i;
        }
    if (x > 1) res = res / x * (x - 1);
    return res;
}
```



#### 筛法求欧拉函数

```cpp
int primes[N], cnt;     // primes[]存储所有素数
int euler[N];           // 存储每个数的欧拉函数
bool st[N];         // st[x]存储x是否被筛掉
void get_eulers(int n)
{
    euler[1] = 1;
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i])
        {
            primes[cnt ++ ] = i;
            euler[i] = i - 1;
        }
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            int t = primes[j] * i;
            st[t] = true;
            if (i % primes[j] == 0)
            {
                euler[t] = euler[i] * primes[j];
                break;
            }
            euler[t] = euler[i] * (primes[j] - 1);
        }
    }
}
```



### 快速幂

**求 $a^b \pmod{p}$，时间复杂度 $O(\log k)$**

```cpp
int fastpow(int a, int b,int p)
{
    int ans = 1;
    while (b)
    {
        if (b & 1) ans = 1ll * ans * a % p;
        a = 1ll * a * a % p;
        b >>= 1;
    }
    return ans;
}
```

**乘法逆元：**若 $b,m$ 互质，并且对于任意整数 $a$ 如果满足 $b|a$ ，则存在一个整数 $x$ ，使得 $\frac{a}{b}\equiv a \times x\pmod{m}$ ，则称 $x$ 为 $b$ 的模 $m$ 乘法逆元，记为 $b^{-1}\pmod{m}$

$b$ 存在乘法逆元的充要条件是 $b$ 与模数 $m$ 互质，当模数 $m$ 为质数时，$b^{m-2}$ 即为 $b$ 的乘法逆元



### 扩展欧几里得算法

**裴蜀定理：**对于任意两个整数 $a$ 和 $b$，存在整数 $x$ 和 $y$，使得$ax+by=gcd⁡(a,b)$

```cpp
// 求x, y，使得ax + by = gcd(a, b)
int exgcd(int a, int b, int &x, int &y)
{
    if (!b)
    {
        x = 1; y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= (a/b) * x;
    return d;
}
```



### 高斯消元

$O(n^3)$

**步骤：**

1.   构造增广矩阵
2.   前向消元，使矩阵变成上三角矩阵
3.   回代求解

```cpp
int gauss()// a[N][N]是增广矩阵
{
    int c, r;
    for (c = 0, r = 0; c < n; c ++ )
    {
        int t = r;
        for (int i = r; i < n; i ++ )//找到绝对值最大的行
            if (fabs(a[i][c]) > fabs(a[t][c]))
                t = i;
        if (fabs(a[t][c]) < eps) continue;
        for (int i = c; i <= n; i ++ ) swap(a[t][i], a[r][i]);//将绝对值最大的行换到最顶端
        for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];//将当前行的首位变成1
        for (int i = r + 1; i < n; i ++ )//用当前行将下面所有的列消成0
            if (fabs(a[i][c]) > eps)
                for (int j = n; j >= c; j -- )
                    a[i][j] -= a[r][j] * a[i][c];
        r ++ ;
    }
    
    if (r < n)
    {
        for (int i = r; i < n; i ++ )
            if (fabs(a[i][n]) > eps)
                return 2; // 无解
        return 1; // 有无穷多组解
    }
    //回代求解
    for (int i = n - 1; i >= 0; i -- )
        for (int j = i + 1; j < n; j ++ )
            a[i][n] -= a[i][j] * a[j][n];
    return 0; // 有唯一解
}
```

```cpp
#include <iostream>
#include <cmath>
using namespace std;
double a[110][110];
int n;
double eps = 1e-7;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n+1;j++)
            scanf("%lf",&a[i][j]);
    for(int i=1;i<=n;i++)
    {
        int max=i;
        for(int j=i+1;j<=n;j++)
            if(fabs(a[j][i])>fabs(a[max][i])) max=j;
        for(int j=1;j<=n+1;j++) swap(a[i][j],a[max][j]);
        if(fabs(a[i][i])<eps)
        {
            puts("No Solution");
            return 0;
        }
        for(int j=n+1;j>=1;j--) a[i][j]=a[i][j]/a[i][i]; // 倒着遍历，避免修改a[i][i];
        for(int j=1;j<=n;j++)
        {
            if(j!=i)
            {
                double temp=a[j][i]/a[i][i];
                for(int k=1;k<=n+1;k++) a[j][k]-=a[i][k]*temp;
            }
        }
    }
    for(int i=1;i<=n;i++) printf("%.2f\n",a[i][n+1]);
    return 0;
}
```



### 组合数

#### 递推法求组合数

$C^b_a=C_{a-1}^b+C_{a-1}^{b-1}$

```cpp
// c[a][b] 表示从a个苹果中选b个的方案数
for (int i = 0; i < N; i ++ )
    for (int j = 0; j <= i; j ++ )
        if (!j) c[i][j] = 1;
        else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
```



#### 预处理逆元求组合数

```cpp
//首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N]
//如果取模的数是质数，可以用费马小定理求逆元
int qmi(int a, int k, int p)//快速幂模板
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}
// 预处理阶乘的余数和阶乘逆元的余数
fact[0] = infact[0] = 1;
for (int i = 1; i < N; i ++ )
{
    fact[i] = (LL)fact[i - 1] * i % mod;
    infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
}
```



#### $Lucas$ 定理

**若 $p$ 是质数，则对于任意整数 $1\leqslant m \leqslant n$，有：**

$$C^n_m=C^{n\%p}_{m\%p}\times C^{n/p}_{m/p}\mod p$$

```cpp
int qmi(int a, int k, int p)  // 快速幂模板
{
    int res = 1 % p;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}
int C(int a, int b, int p)  // 通过定理求组合数C(a, b)
{
    if (a < b) return 0;
    LL x = 1, y = 1;  // x是分子，y是分母
    for (int i = a, j = 1; j <= b; i --, j ++ )
    {
        x = (LL)x * i % p;
        y = (LL) y * j % p;
    }
    return x * (LL)qmi(y, p - 2, p) % p;
}
int lucas(LL a, LL b, int p)
{
    if (a < p && b < p) return C(a, b, p);
    return (LL)C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;
}
```



#### 分解质因数法求组合数

需要求出组合数的真实值，而非对某个数的余数时，适合用分解质因数的方式：

1.   筛法求出范围内的所有质数
2.   通过 $\mathrm{C}^a_b=\cfrac{a!}{b!(a-b)!}$ 求出每个质因子的次数，$n!$ 中 $p$ 的次数是$\cfrac{n}{p}+\cfrac{n}{p^2}+\cfrac{n}{p^3}+\cdots$
3.   用高精乘相乘所有质因子

```cpp
int primes[N], cnt;     // 存储所有质数
int sum[N];     // 存储每个质数的次数
bool st[N];     // 存储每个数是否已被筛掉
void get_primes(int n)      // 线性筛法求素数
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}
int get(int n, int p)       // 求 n！中的次数
{
    int res = 0;
    while (n)
    {
        res += n / p;
        n /= p;
    }
    return res;
}
vector<int> mul(vector<int> a, int b)       // 高精度乘低精度模板
{
    vector<int> c;
    int t = 0;
    for (int i = 0; i < a.size(); i ++ )
    {
        t += a[i] * b;
        c.push_back(t % 10);
        t /= 10;
    }
    while (t)
    {
        c.push_back(t % 10);
        t /= 10;
    }
    return c;
}
get_primes(a);  // 预处理范围内的所有质数
for (int i = 0; i < cnt; i ++ )     // 求每个质因数的次数
{
    int p = primes[i];
    sum[i] = get(a, p) - get(b, p) - get(a - b, p);
}
vector<int> res;
res.push_back(1);
for (int i = 0; i < cnt; i ++ )     // 用高精度乘法将所有质因子相乘
    for (int j = 0; j < sum[i]; j ++ )
        res = mul(res, primes[i]);
```

