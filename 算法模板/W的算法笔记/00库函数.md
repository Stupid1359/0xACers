## C++ STL

### Vector

**变长数组，在末尾进行元素增删**

1.   **声明**

     ```cpp
     #include<vector>
     vector<int>a;//长度动态变化的数组
     vector<int> b[233];//第二维长度变化
     vector<int> a(10)//包含 10 个 int 类型,默认值 0
     vector<int> b(10,3)//初始值为 5
     struct rec{...};vector<rec> c;//结构体类型
     vector<int>::iterator it;//迭代器（指针）
     ```

2.   **size/empty** 

     `size()`返回实际长度，`empty()`返回`bool`类型检测是否为空

3.   **clear** 清空`vector` 

4.   **begin/end** 

     `begin()`返回第一个元素，`end()`返回最后一个元素的下一个元素（边界）

     ```cpp
     //遍历
     for(int i=0;i<a.size();i++)
         cout<<a[i]<<endl;
     for(vector<int>::iterator it=a.begin();it!=a.end();it++)
         cout<<*it<<endl;
     for(auto x:a) cout<<x<<endl;
     ```

5.   **front/back** 

     `front()`返回第一个元素，`back()`返回最后一个元素

     ```cpp
     vector<int> a({1,2,3});
     cout<<a.front()<<" "<<a[0]<<endl;
     cout<<a.back()<<" "<<a[a.size()-1]<<endl;
     ```

6.   **push_back/pop_back**

     `push_back()`把元素插入到尾部，`pop_back()`删除最后一个元素 O(1)
     
     ```cpp
     a.push_back(4);
     a.pop_back();
     ```
     
7.   **支持按字典序比较运算**

     ```cpp
     vector<int> a(4,3),b(3,4);
     if(a<b) puts("a<b");
     ```



### Pair

**存储一对值**

1.   **声明**

     ```cpp
     pair<int,double> p;//存储 int 和 double 的 pair
     pair<int,double> p(1,3.14);//初始化
     pair<int,string> p=make_pair(10,"abc");//用 make_pair 构造
     p=(20,"abc");//C++11
     pair<string,pair<int,int>> p;//存储三个数据
     ```

2.   **first/second**

     `a.first/a.second`访问第一个和第二个数据



### String

1.   **size/length** 返回字符串长度

     **empty** 检查是否为空

     **clear** 清空字符串

2.   **c_str** 

     `a.c_str()`返回字符串`a`的起始地址

3.   **append**

     向字符串末尾添加内容

     ```cpp
     a+="def";
     a.append("hij");//添加 "hij"
     a.append(n,'*');//添加 n个字符
     a.append(str,pos,len);//从位置 pos开始添加长度为 len的字符串
     ```

4.   **substr**

     提取字串，`a.substr(3,5)`表示从下标为 $3$ 开始提取 $5$ 个字符，若超出字符串长度，只输出到字符串末尾，`a.substr(3)`表示从 $3$ 开始的整个子串

5.   **insert**

     ```cpp
     a.insert(5,"hello");//在位置 5 插入
     a.insert(pos,n,c);//在位置 pos插入 n个字符 c
     a.insert(pos,str,subpos,sublen);//将子字符串 str从 subpos起 sublen长度的子串插入到位置 pos
     ```

6.   **find**

     ```cpp
     a.find(str);//在 a中查找子字符串/字符 str
     a.find(str,pos);//从位置 pos开始查找
     ```

7.   **replace**

     ```cpp
     replace(pos,len,str);//从 pos开始替换 len个字符为字符串 str
     replace(pos,len,c);//从 pos开始替换 len个字符 变为 n个字符 c
     ```



### Queue

**包含 循环队列`queue` 和 优先队列`priority_queue`(堆) 两个容器**

1.   **声明**

     ```cpp
     #include<queue>
     queue<int> q;
     queue<double> a;
     pirority_queue<int> a;//大根堆
     pirority_queue<int,vector<int>,greater<int>> b;//小根堆
     pirority_queue<pair<int,int>> q;//双元组
     struct rec
     {
     	int a,b;
         bool operator< (const rec& t) const
         {
             return a < t.a;
     	}//重载小于号
     };
     priority_queue<rec> q;
     //用大根堆重载小于号，用小根堆重载大于号
     priority_queue<rec,vector<rec>,greater<rec>> d;
     ```

2.   **queue**

     *   **push** 从队尾插入

         **pop** 从队头弹出

     *   **front** 返回队头元素

         **back** 返回队尾元素

3.   **priority_queue**（默认大根堆）

     *   **push** 把元素插入堆
     *   **pop** 删除堆顶元素(最大值)
     *   **top** 查询堆顶元素(最大值)

4.   **q=queue<int>();**

     无`clear` 函数，重新触发使之清除



### Stack

1.   **头文件** `#include<stack>`

2.   **push** 向栈顶插入

     **pop** 弹出栈顶元素
     
     ```cpp
     stack<int> stk;
     stk.push(1);
     stk.pop();
     ```
     



### Deque

**支持在两端插入删除，速度较慢**

1.   **头文件** `#include<deque>`

2.   **begin/end** 返回`deque`的头/尾迭代器

     **front/back** 队头/队尾元素

3.   **push_back** 从队尾入队

     **push_front** 从队头入队 $O(1)$

4.   **pop_back** 从队尾出队

     **pop_front** 从队头出队 $O(1)$

5.   **clear** 清空队列

     ```cpp
     deque<int> a;
     a.begin(),a.end();
     a.front(),a.back();
     ```




### Set

**包括 有序集合`set` 和 多重有序集合`multiset`  两个容器，内部实现是一颗红黑树**

1.   **声明**

     ```cpp
     #include<set>
     set<int> s;
     struct rec
     {
     	int x,y;
         bool operator< (const rec& t) const
         {
     		return x < t.x;
         }//重载小于号
     };set<rec> s;
     multiset<double> s;
     set<int>::iterator it;
     ```

2.   **size/empty/clear** $O(1)$

3.   **begin/end**

     指向集合首尾迭代器 $O(1)$

     `begin`指向最小元素的迭代器，`end`指向最大元素下一个位置的迭代器

4.   **insert**

     插入元素，若元素已存在则不重复插入 $O(\log n)$

     ```cpp
     if(a.find(x)==a.end())//判断x在a中是否存在
     ```

5.   **lower_bound/upper_bound**

     ```cpp
     //找到大于等于 x 的最小元素的迭代器
     s.lower_bound(x);
     //找到大于 x 的最小元素的迭代器
     s.upper_bound(x); 
     ```

6.   **erase**

     ```cpp
     s.erase(it)
     //删除迭代器 it 指向的元素 O(log n)
     s.erase(x)
     //删除所有等于 x 的元素 O(k + log n) k是 x的个数
     ```

7.   **count**

     ```cpp
     s.count(x)
     //返回等于 x 的元素个数 O(k + log n) k 为元素 x 的个数
     ```

8.   **unordered_set**

     **底层实现为哈希表，无`lower_bound/upper_bound`，复杂度$O(1)$，可以存储重复元素**

     ```cpp
     #include<unordered_set>
     unordered_set<int> s;
     unordered_multiset<int> b;
     ```



### Map

**键值对 key_value 的映射，内部实现是一颗以key为关键码的红黑树，Map的key和value可以是任意类型，其中key必须定义为小于号运算符**

1.   **声明**

     ```cpp
     #include<map>
     map<key_type,value_type> name;
     map<string,int> hash;
     map<pair<int,int>,vector<int>> test;
     ```

     ```cpp
     map<string,vector<int>> a;
     a["abc"]=vector<int>({1,2,3,4});
     cout<<a["abc"][2]<<endl;
     ```

2.   **size/empty/clear/begin/end** 均与`set`类似 

3.   **insert/erase** 均类似，但参数均是`pair<key_type,value_type>`

4.   **find**

     ```cpp
     h.find(x)
     //在变量名为 h 的 map 中查找 key 为  x 的二元组
     ```

5.   **[ ]操作符**

     ```cpp
     h[key]//返回 key 映射的 value 的引用 O(log n)
     map<string,int> a;
     a["abc"]=1;cout<<a["abc"];
     ```

6.   **unordered_map**

     ```cpp
     #include<unordered_map>
     unordered_map<int> c;
     ```



### Bitset

**压位**

**支持操作符：~  &  |  ^  >>  <<  ==  !=  [ ]**

1.   **声明**

     ```cpp
     #include<bitset>
     bitset<100> b;//长度为 100的 01串,初始化为 0
     bitset<Size> b("11010101");//二进制字符串初始化
     bitset<8> b(255);//整数初始化
     ```

2.   **count**

     `a.count()`返回 1 的个数

3.   **any/none**

     `a.any()`判断是否至少有一个 1，`a.none()`判断是否全为 0，是则返回`true`，否则返回`false`

4.   **set/reset**

     ```cpp
     a.set();//把所有位置成 1
     a.set(k,v);//把第 k位变成 v
     a.reset();//把所有位变成 0
     ```

5.   **flip**

     ```cpp
     a.filp();//等价于 ~
     a.filp(k);//把第 k 位取反
     ```



## Algorithm库函数

### Reverse

**翻转 O(1)** 

```cpp
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
int main()
{
	vector<int> a({1,2,3,4,5});
    int b[]={1,2,3,4,5};
    reverse(a.begin(),a.end());
    reverse(a,a+5);
}
```

### Unique

**去重，返回去重之后的尾迭代器，可计算出去重后元素个数，使用前元素必须有序**

```cpp
int a[]={1,1,2,2,3,3,4};
vector<int> a({1,1,2,2,3,3,4});
int m=unique(a,a+7)-a;
int n=unqiue(b.begin(),b.end())-b.begin();
//b.erase(unqiue(b.begin(),b.end()),b.end);删除后面的元素
cout<<m<<endl<<n<<endl;
for(int i=0;i<m;i++)
    cout<<a[i]<<" ";
```

```cpp
vector<int>::iterator unique(vector<int> &a) { //具体实现
	int j=0;
    for(int i=0;i<a.size();i++)
        if(!i || a[i]!=a[i-1])
            a[j++]=a[i];
    return a.begin()+j;
}
```

### Random_shuffle

```cpp
#include<ctime>
srand(time(0));//1970.1.1到现在的秒数
random_shuffle(a.begin(),a.end());
```

### Sort

```cpp
//通过 cmp 实现
struct rec
{
	int x,y;
}a[5];
bool cmp(int a,int b)//a 是否排在 b 的前面
{
    return a>b
}
sort(a+1,a+1+n,cmp);//从 a[1] 开始排序
//通过重载实现
struct Rec
{
	int a,b;
    bool operator < (const Rec &t) const
    {
		return x < t.x;
    }
}a[5];
sort(a,a+n);
```

### Lower_bound/Upper_bound

**`lower_bound`在两个迭代器指定的部分二分查找，返回指向第一个大于等于 第三个参数 的元素的迭代器**

**`upper_bound`查找第一个大于 第三个参数 的元素**

**指定部分应提前排好序**

```cpp
//查找大于等于 x 的最小整数的下标
int i=lower_bound(a+1,a+1+n,x)-a;
//查找小于等于 x 的最大整数
int y=*--upper_bound(a.begin(),a.end(),x);
```